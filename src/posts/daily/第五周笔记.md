## 1.组件注册

（1）全局注册

​	使用app.component注册全局组件

```vue
import MyComponent from './App.vue'
app.component('MyComponent', MyComponent)
```

（2）局部注册

​	使用import实现单文件组件注册

```vue
<script setup>
import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>
```

## 2.Props

（1）defineProps

​	使用defineProps实现父组件向子组件传值，并使用

```vue
<!-- 子组件声明props-->
<script setup>
    const props = defineProps(['foo'])
    //也可以使用下述声明
    defineProps({
        title: String,
        likes: Number
    })
    console.log(props.foo)
</script>
<!-- 父组件传值，子组件声明的props名称为greetingMessage-->
<MyComponent greeting-message="hello" />
<!-- 根据一个变量的值动态传入 -->
<BlogPost :title="post.title" />

<!-- 根据一个更复杂表达式的值动态传入 -->
<BlogPost :title="post.title + ' by ' + post.author.name" />

<!-- 使用对象绑定prop-->
const post = {
id: 1,
title: 'My Journey with Vue'
}
<BlogPost v-bind="post" />
<!--等价于-->
<BlogPost :id="post.id" :title="post.title" />
```

（2）prop校验

```js
defineProps({
    // 基础类型检查
    // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）
    propA: Number,
    // 多种可能的类型
    propB: [String, Number],
    // 必传，且为 String 类型
    propC: {
        type: String,
        required: true
    },
    // 必传但可为 null 的字符串
    propD: {
        type: [String, null],
        required: true
    },
    // Number 类型的默认值
    propE: {
        type: Number,
        default: 100
    },
    // 对象类型的默认值
    propF: {
        type: Object,
        // 对象或数组的默认值
        // 必须从一个工厂函数返回。
        // 该函数接收组件所接收到的原始 prop 作为参数。
        default(rawProps) {
            return { message: 'hello' }
        }
    },
    // 自定义类型校验函数
    // 在 3.4+ 中完整的 props 作为第二个参数传入
    propG: {
        validator(value, props) {
            // The value must match one of these strings
            return ['success', 'warning', 'danger'].includes(value)
        }
    },
    // 函数类型的默认值
    propH: {
        type: Function,
        // 不像对象或数组的默认，这不是一个
        // 工厂函数。这会是一个用来作为默认值的函数
        default() {
            return 'Default function'
        }
    }
})
```

## 3.事件传递

（1）$emit声明

​	在子组件中使用 $emit="event"来向父组件抛出一个事件名，父组件使用v-on(@)来监听事件

```vue
<!-- MyComponent -->
<button @click="$emit('someEvent')">Click Me</button>
<MyComponent @some-event="callback" />
<!-- 可以使用修饰符 -->
<MyComponent @some-event.once="callback" />
```

（2）defineEmits	

​	在子组件可以通过defineEmits批量声明需要触发的事件

```vue
<script setup>
    const emit = defineEmits(['inFocus', 'submit'])
    //通过返回的emit可以直接调用父组件定义的事件
    function buttonClick() {
        emit('submit')
    }
</script>

<!--也可以声明时校验-->
<script setup>
    const emit = defineEmits({
        // 没有校验
        click: null,

        // 校验 submit 事件
        submit: ({ email, password }) => {
            if (email && password) {
                return true
            } else {
                console.warn('Invalid submit event payload!')
                return false
            }
        }
    })

    function submitForm(email, password) {
        emit('submit', { email, password })
    }
</script>
```

## 4.V-Model

（1）使用defineModel宏实现绑定

```vue
<!-- Child.vue -->
<script setup>
    const model = defineModel()

    function update() {
        model.value++
    }
</script>

<template>
<div>Parent bound v-model is: {{ model }}</div>
<button @click="update">Increment</button>
</template>
<!-- Parent.vue -->
<Child v-model="countModel" />
```

​	每一个对象使用一个definemodel声明，组件上也可以声明一个参数来绑定model内的属性

```vue
<MyComponent v-model:title="bookTitle" />

<!-- MyComponent.vue -->
<script setup>
const title = defineModel('title')
</script>

<template>
  <input type="text" v-model="title" />
</template>
```

（2）model宏的修饰符

​	可以自定义model的修饰符，实现自定义属性的启用

```vue
<script setup>
const [model, modifiers] = defineModel({
  set(value) {
        if (modifiers.capitalize) {
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
    return value
  }
})
</script>

<template>
  <input type="text" v-model="model" />
</template>

<MyComponent v-model.capitalize="myText" />
```

## 5.透传

​	当子组件没有声明属性名的时候，如果父组件传来一个属性名，则子组件会自动继承父组件的属性

```vue
<!-- <MyButton> 的模板 -->
<button>Click Me</button>

<MyButton class="large" />

<button class="large">Click Me</button>
```

​	如果子组件拥有一个class，此时两个class会自动合并，v-on也会被继承，使用defineOptions({  inheritAttrs: false })实现阻止继承，此时使用v-bind="$attrs"实现继承，拥有多个根节点时，需要手动使用v-bind绑定透传

## 6.插槽（slot）

​	在父组件没有传入数据时，可以给插槽默认数据，如果传入则插槽默认数据被覆盖

```vue
<button type="submit">
  <slot>
    Submit <!-- 默认内容 -->
  </slot>
</button>
```

​	可以为插槽命名，实现不同插槽显示不同内容，父组件通过v-slot:{{name}}实现指定插槽渲染(简写成#)

```vue
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>

<BaseLayout>
  <template v-slot:header>
    <!-- header 插槽的内容放这里 -->
  </template>
</BaseLayout>

<!-- 例如-->
<BaseLayout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <template #default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</BaseLayout>
```

​	可以通过prop传递数据

```vue
<!-- <MyComponent> 的模板 -->
<div>
  <slot :text="greetingMessage" :count="1"></slot>
</div>

<MyComponent v-slot="slotProps">
  {{ slotProps.text }} {{ slotProps.count }}
</MyComponent>
```

