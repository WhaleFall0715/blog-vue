---
date: 2025-08-13
category:
  - 日常博客
tag:
  - 日常
  - 工作笔记
sticky: false
---

<!-- more -->

1. ### VUE3 使用 setup 作为返回数据的框架，在 script 标签加上 setup 就可以实现 vue2 中的 data 之类的功能

2. ### 使用 ref 和 reactive 实现响应式数据

类与样式绑定就是 v-bind:class(简写:class)，v-bind:style(简写:style)使用 ref 实现动态绑定，class 内使用（{className}：{boolean}）启用或不用 class

基本数据使用 ref 实现

```vue
<template>
  <div>姓名：{{ name }}</div>
</template>
<script setup>
let name = ref("张三"); //变为响应式数据
</script>
```

​ 对象使用 reactive 实现，会将对象变成 proxy 对象，reactive 只能定义对象数据，使用 shallowReactive 实现浅层监听

```vue
<template>
  <h2>一辆{{ car.name }}，价值{{ car.price }}</h2>
  <button @click="changeCarPrice">加价</button>
</template>

<script setup name="jiliguala">
import { reactive } from "vue";

let car = reactive({
  name: "aito",
  price: 100,
});
function changeCarPrice() {
  car.price += 100;
}
</script>
```

​ ref 实现对象数据的响应式

```vue
<template>
  <h2>一辆{{ car.name }}，价值{{ car.price }}</h2>
  <button @click="changeCarPrice">加价</button>
  <br />
  <h2>游戏列表：</h2>
  <ul>
    <li v-for="item in games" :key="item.id">
      <h3>{{ item.id }}</h3>
      <p>{{ item.name }}</p>
    </li>
  </ul>
</template>

<script setup name="jiliguala">
import { ref } from "vue";

let car = ref({
  name: "aito",
  price: 100,
});
let games = ref([
  { id: "A12301", name: "三国杀" },
  { id: "A12302", name: "暗区突围" },
  { id: "A12303", name: "原神启动" },
]);
function changeCarPrice() {
  //想要修改数据，必须对象.value才能访问并修改
  car.value.price += 100;
  console.log(car);
}
</script>
```

区别：ref 访问对象值必须用 value 访问，只要访问 value 就可以修改成响应式数据，在给 reactive 对象重新分配时，会失去响应式属性，例如：

```vue
<script setup name="jiliguala">
import { reactive } from "vue";

let games = reactive([
  { id: "A12301", name: "三国杀" },
  { id: "A12302", name: "暗区突围" },
  { id: "A12303", name: "原神启动" },
]);

function changeGamesList() {
  //此时games会被赋值一个新对象，失去响应式属性
  games = [{ id: "A12304", name: "CF" }];
  //此时依然无法变成响应式数据，在setup中返回的是本来games的引用，现在新赋值无法改变源地址的信息
  games = recative([{ id: "A12304", name: "CF" }]);
  //正确引用应该是下述,使用assign修改v1地址内的信息，使用v2赋值到v1
  Object.assign(games, [{ id: "A12304", name: "CF" }]);
}
</script>
```

除深层响应式对象之外，都推荐使用 ref

**解构后**数据不为响应式对象

```vue
<script setup name="jiliguala">
import { reactive } from "vue";

let car = reactive({
  name: "aito",
  price: 100,
});
//解构赋值之后，name和price被解构成基本数据类型，失去响应式布局，只是浅拷贝
let { name, price } = car;
//此时解构赋值变成响应式对象
let { name, price } = toRefs(car);
//此时car内的name也会被影响，相当于深拷贝，对name进行引用
name.value = "111";
//也可以
let n = toRef(car, "name");
function changeCarPrice() {
  //想要修改数据，必须对象.value才能访问并修改
  car.value.price += 100;
  console.log(car);
}
</script>
```

### 响应式对象的重新赋值

当用 reactive 定义响应式对象时，重新赋值不会丢失对对象的监听，但是会丢失对对象内部属性的监听，例如

```vue
<script setup>
import { reactive, ref, watch } from "vue";
import { resolveTypeElements } from "vue/compiler-sfc";
let ob = reactive({
  obx: 0,
  oby: 0,
  innerOb: {
    innerObBoolean: false,
  },
});
//重新赋值ob，此时不丢失对ob的监听，但是会丢失对innerOb的监听
function resetOb() {
  Object.assign(ob, { obx: 0, oby: 0, innerOb: { innerObBoolean: false } });
}
//重新赋值innerOb，此时不丢失对innerOb的监听，重新赋值后会触发ob的监听
function resetInnerOb() {
  Object.assign(ob.innerOb, { innerObBoolean: false });
}
//重新赋值之后此监听不丢失
watch(ob, (newOb) => {
  console.log(`obx is ${newOb.obx} and oby is ${newOb.oby}`);
});
//此监听不生效，因为x和y不为响应式对象
watch([ob.x, ob.y], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`);
});
//此监听不生效，因为x不为响应式对象
watch(ob.x, (newX) => {
  console.log(`x is ${newX}`);
});
//此监听生效
watch(ob.innerOb, (newInnerOb) => {
  console.log(`innerObBoolean is ${newInnerOb.innerObBoolean}`);
});
</script>
```

当响应式对象使用 ref 定义时，无论使用 new ref() OR Object.assign()都会丢失对象的监听，使用直接赋值不会丢失对对象的监听，但是会丢失对对象内部对象的监听

```vue
<script setup>
import { reactive, ref, watch } from "vue";
import { resolveTypeElements } from "vue/compiler-sfc";
let ob = ref({
  obx: 0,
  oby: 0,
  innerOb: {
    innerObBoolean: false,
  },
});
function resetOb() {
  // Object.assign(ob, { obx: 0, oby: 0, innerOb: { innerObBoolean: false } });
  // ob = ref({ obx: 0, oby: 0, innerOb: { innerObBoolean: false } });
  //这样赋值不会丢失对ob的监听，但是会丢失对innerOb的监听
  ob.value = { obx: 0, oby: 0, innerOb: { innerObBoolean: false } };
}
</script>
```

3. 双向绑定以及 compute 函数

   使用 v-modle 和响应式对象进行数据绑定

```vue
<template>
  <h2>一辆{{ car.name }}，价值{{ car.price }}</h2>
  <button @click="changeCarPrice">加价</button>
  <br />
  //在这下面的input内绑定price，输入时改变上面price内容
  <input type="text" v-model="price" />
</template>

<script setup name="jiliguala">
import { reactive, ref, toRef, toRefs } from "vue";

let car = reactive({
  name: "aito",
  price: 100,
});
//使用reactive和toRef实现绑定响应式对象
let price = toRef(car, "price");
function changeCarPrice() {
  car.price += 100;
  console.log(car);
}
</script>
```

使用 compute()实现对数据的渲染，当计算使用的数据发生变化时，会立马重新计算，拥有缓存，并且可以修改是否只读

```vue
<template>
  <h2>一辆{{ car.name }}，价值{{ car.price }}</h2>
  <h2>八折价格为:{{ finPrice }}</h2>
  <button @click="changeCarPrice">加价</button>
  <input type="text" v-model="price" />
</template>

<script setup name="jiliguala">
import { computed, reactive, ref, toRef, toRefs } from "vue";

let car = reactive({
  name: "aito",
  price: 100,
});
let price = toRef(car, "price");
function changeCarPrice() {
  car.price += 100;
  console.log(car);
}
//计算属性，这样设置只读
let finPrice = computed(() => {
  return car.price * 0.8;
});
//这样设置可写可读
let finPrice = computed({
  get() {
    return car.price * 0.8;
  },
  set(val) {
    car.price = val;
  },
});
</script>
```

4. ### watch 监听

   只能监听以下数据

![](https://gitee.com/dufei_handsome/mypic/raw/master/20250808103132.png)

​ 使用 watch(object,(newVal,oldVal),{attribute：boolean})=>{...}实现功能，其中 attribute 有：once-只监听一次、immediate-立即执行、deep-手动深层监视

​ 在 ref 定义对象时，watch 只监视对象地址的信息，想要监听对象的内部数据，需要手动开启深度监听

```vue
<script setup name="jiliguala">
import { computed, reactive, ref, toRef, toRefs, watch } from "vue";

let car = ref({
  name: "aito",
  price: 100,
});
function changeName() {
  car.value.name += `~`;
}
function changePrice() {
  car.value.price += 100;
}
function changeCar() {
  car.value = { name: "audo", price: 250 };
}
//监视对象,对象内属性变化时，不发生监听事件
watch(car, (newValue, oldValue) => {
  console("对象变了");
  console.log(newValue, oldValue);
});
//监听属性值
watch(car.value, (newValue, oldValue) => {
  console.log("属性变了");
  console.log(newValue, oldValue);
});
//开启深度监听，属性和对象改变时都会触发，改变属性时，newval和oldval引用相同，会出现log出两个一样属性
watch(
  car,
  (newValue, oldValue) => {
    console.log("深度监听出现了");
    console.log(newValue, oldValue);
  },
  { deep: true }
);
</script>
```

​ 使用 reactive 对象时，监听默认开启深度监听，在修改整个对象时，只对属性进行赋值，而不改变地址，使用 watch(()=>{return object.属性},(newVal,oldVal)=>{...}进行 reactive 对象普通属性的监听

​ watchEffect（）也是一个帧听器，是一个副作用函数。 它会监听引用数据类型的所有属性，不需要具体到某个属性，一旦运行就会立即监听，组件卸载的时候会停止监听。并且此监听器会先初始化再执行 DOM 初始化，并且也会先进行监听器事件再更新 DOM。使用 flush：“post”属性实现更新 DOM 后执行监听，也可以使用 watchPostEffect 监听器。停止监听只需要使用一个对象接受创建 watch 时返回的函数，然后再执行就可以实现。

5. ### 条件渲染

   使用&lt;v-if = "boolean"&gt;和&lt;v-else&gt;和&lt;v-else-if&gt;实现条件渲染，决定 DOM 是否对该组件进行渲染，在切换状态时会对组件进行销毁和创建，如果想 DOM 对组件进行渲染但是不显示则使用&lt;v-show&gt;实现

6. ### 列表渲染

   使用 v-for 属性对&lt;li&gt;标签进行渲染，语法为 v-for="(item index) in items"，可以对对象进行循环渲染 v-for="(value,key,index) of Object"，v-if 要比 v-for 优先级高，同时使用 v-if 访问 item 时会无法调用 item 内的属性

7. ### 事件处理

   触发属性

   ```vue
   <!-- 单击事件将停止传递 -->
   <a @click.stop="doThis"></a>

   <!-- 提交事件将不再重新加载页面 -->
   <form @submit.prevent="onSubmit"></form>

   <!-- 修饰语可以使用链式书写 -->
   <a @click.stop.prevent="doThat"></a>

   <!-- 也可以只有修饰符 -->
   <form @submit.prevent></form>

   <!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->
   <!-- 例如：事件处理器不来自子元素 -->
   <div @click.self="doThat">...</div>

   <!-- 添加事件监听器时，使用 `capture` 捕获模式 -->
   <!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 -->
   <div @click.capture="doThis">...</div>

   <!-- 点击事件最多被触发一次 -->
   <a @click.once="doThis"></a>

   <!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->
   <!-- 以防其中包含 `event.preventDefault()` -->
   <div @scroll.passive="onScroll">...</div>

   <!-- 仅在 `key` 为 `Enter` 时调用 `submit` -->
   <input @keyup.enter="submit" />

   <input @keyup.page-down="onPageDown" />
   ```

   8. ### 表单绑定

      &lt;input&gt;标签使用 v-model 绑定输入内容，使用 ref 实现响应式输入，使用 v-modle.{{attribute}}实现简单校验：number-仅数字、.trim 去除输入前后空格

      &lt;checkbox&gt;标签使用 v-model 绑定是否选中，也可以使用 ref([])实现多项绑定

      可以使用 v-for 绑定 option 内容，例如

      ```vue
      const selected = ref('A') const options = ref([ { text: 'One', value: 'A'
      }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ])

      <select v-model="selected">
        <option v-for="option in options" :value="option.value">
          {{ option.text }}
        </option>
      </select>

      <div>Selected: {{ selected }}</div>
      ```

   9. ### 模板引用

      在标签内使用 ref = "name"和在 js 使用对象 let name = useTemplateRef()实现对标签的直接引用

      ```vue
      <template>
        <video ref="myVideo" src="video.mp4"></video>
        <button @click="play">播放</button>
      </template>

      <script setup>
      const myVideo = useTemplateRef(null);

      const play = () => {
        myVideo.value.play(); // 直接调用视频方法
      };
      </script>
      ```

   10. ### 组件基础

       使用 import 引入外部组件

       ```vue
       <script setup>
       import ButtonCounter from "./ButtonCounter.vue";
       </script>

       <template>
         <h1>Here is a child component!</h1>
         <ButtonCounter />
       </template>
       ```

       使用 defineProps 实现属性传入

       ```vue
       //BlogPost.vue
       <script setup>
       defineProps(["id", "title"]);
       </script>

       <template>
         <h4>{{ id }}</h4>
         <h4>{{ title }}</h4>
       </template>
       ```

       ```vue
       <script setup>
       import { ref } from "vue";
       import BlogPost from "./BlogPost.vue";

       const posts = ref([
         { id: 1, title: "My journey with Vue" },
         { id: 2, title: "Blogging with Vue" },
         { id: 3, title: "Why Vue is so fun" },
       ]);
       </script>

       <template>
         <BlogPost
           v-for="post in posts"
           :key="post.id"
           :title="post.title"
           :id="post.id"
         ></BlogPost>
       </template>
       ```

       使用$emit 实现事件的抛出

       ```vue
       <script setup>
       defineProps(["title"]);
       //在脚本内暴露出事件
       defineEmits(["enlarge-text", "change-color"]);
       </script>

       <template>
         <div class="blog-post">
           <h4>{{ title }}</h4>
           //在button内声明需要抛出的事件
           <button @click="$emit('enlarge-text')">Enlarge text</button>
           <button @click="$emit('change-color')">Change color</button>
         </div>
       </template>
       ```

       ```vue
       <script setup>
       import { ref } from 'vue'
       import BlogPost from './BlogPost.vue'

       const posts = ref([
         { id: 1, title: 'My journey with Vue' },
         { id: 2, title: 'Blogging with Vue' },
         { id: 3, title: 'Why Vue is so fun' }
       ])

       const postFontSize = ref(1)
       const colorBool = ref(false)
       </script>

       <template>
       	<div :style="{ fontSize: postFontSize + 'em' ,color: colorBool ? 'red' : 'black'}">
           <BlogPost
             v-for="post in posts"
             :key="post.id"
             :title="post.title"
                     //定义方法的内容
             @enlarge-text="postFontSize += 0.1"
             @change-color="colorBool = !colorBool"
           ></BlogPost>
         </div>
       </template>
       ```

       将 prop 属性声明类别

       ```vue
       <script setup lang="ts">
       //运行时声明,当作参数传入
       const props = defineProps({
         foo: { type: String, required: true },
         bar: Number,
       });

       props.foo; // string
       props.bar; // number | undefined
       //基于类型声明,当作属性传入
       const props = defineProps<{
         foo: string;
         bar?: number;
       }>();
       //抽象化为接口声明类别
       interface Props {
         foo: string;
         bar?: number;
       }
       const props = defineProps<Props>();
       </script>
       ```

       父组件内传入的单独文本在子组件使用&lt;/slot&gt;展示出来

   11. ### 生命周期

       onMounted 钩子函数为 DOM 渲染完成时调用,onUpdate 钩子函数在 DOM 和响应式对象发生变化使得组件重新渲染变化时调用,onUnmounted 在组件被卸载时调用,onErrorCaptured 在捕获了后代组件传递的错误时调用,onActivated 若组件实例是 &lt;KeepAlive&gt; 缓存树的一部分，当组件被插入到 DOM 中时调用,onDeactivated 移除时调用

       <img src="https://gitee.com/dufei_handsome/mypic/raw/master/20250808103159.png" alt="组件生命周期图示" style="zoom: 67%;" />
