---
title: 牛马日记之第三周
date: 2025-08-13
category:
  - 日常博客
tag:
  - 日常
  - 工作笔记
sticky: false
---

<!-- more -->

## 第三周笔记

## HTML

1. #### 标签

   标题标签：&lt;/h1&gt;&lt;/h2&gt;
   分块标签：

   &lt;/div&gt;

   &lt;/section&gt;-一般用于有明确意义可以分发的分块，内部应该有标题

   &lt;/article&gt;-一般用于有明确独立内容的分组  
   换行标签：

   &lt;/br&gt;

   &lt;/p&gt;-自带上下边距

   超链接标签：

   &lt;/a&gt;-属性：herf 必填，表示目标；target，控制链接打开方式-新标签页、本标签页等；herf 内填写#{{id}}可以对 id 匹配进行跳转

2. #### 属性

   身份属性：id-唯一，class-不唯一

   样式属性：style 常用属性：color 文字颜色；font-size 字体大小；font-family 字体类型；font-weight 字体粗细；text-align 文字对齐；text-decoration 文字装饰：下划线，中划线等；line-height 行高；margin 外边距：与其他组件的边距；padding 内边距：内容与容器的边距；top、right、bottom、left 上下左右定位偏移；transition 过渡效果；transform 变形。

3. #### 表单

   &lt;/form&gt;为表单，基本属性有：action 指定表单提交 url；method 提交方式-GET 和 POST；enctype 编码类型。

   内置标签：

   &lt;/input&gt;标签，属性有：type 输入属性-text、password、email、number、date、file 等；name 字段名称；value 默认值；placeholder 输入框内文本；required 必须字段；readonly 只读；disabled 禁用。

   &lt;/select&gt;标签，下拉菜单选择。

   &lt;/textarea&gt;标签，多行文本，输入区域。

4. #### 图像

   &lt;/img&gt;标签，基本属性有：src 图像源，必填；alt 代替文本，当图像没加载出来时显示；width 和 height 宽高；loading 加载属性，有 lazy-延迟加载和 eager-立即加载；

## CSS

1. #### 选择器：

   基本选择器：\*-选择所有标签；{{tag}}-标签选择器；.{{class}}-类选择器；#{{id}}-ID 选择器

   组合选择器：{{A}}，{{B}}-分组选择；{{A}} {{B}}-选择父容器内所有的子容器；{{A}}>{{B}}-只选择直接子容器；{{A}}+{{B}}-选择同一父容器中的匹配 A 的紧邻 B 容器；{{A}}~{{B}}-选择同一父容器下的匹配 A 的后续所有 B 容器

2. #### 基础属性

外观属性：color 颜色，background 背景，border 边框，box-shadow 容器阴影。

布局属性：

display 展示类型，属性有：block-独占一行可以设置宽高；inline-随行内流动，无法设置宽高（会使 margin 和 padding 上下无效）；inline-block-行内排列可以设置宽高；flex-弹性容器，子内容自由伸缩；gird-二维网格布局，使用 gird-template-columns 设置形式。

```css
 {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* 三列等宽 */
}
```

3. #### 盒模型

由外到内四个层次，依次是 margin-border-padding-content，有两种盒模型：content-box 标准盒模型，总宽度等于外三层一起；border-box 怪异盒模型，总宽度定死大小，不受 padding 和 border 影响。

如果想要网页内容和网页没有间隙，需要将 body 的 margin 和 padding 手动设置为 0，实现没有空隙。

## JavaScript

1. #### 数据类型

number-浮点、整型，string，boolean，null，undefined，symbol-唯一标识符，bigint-大整型

以上为原始类型，在运行时直接取对象值

下面为引用类型，运行时取对象地址，地址数据改变时，所有信息改变

object-键值对集合，array-有序列表，function，Date，RegExp-正则表达式

| 运算符 | 意义         | 例子    | 等同于       | 结果 | 十进制 |
| ------ | ------------ | ------- | ------------ | ---- | ------ |
| &      | 与           | 5 & 1   | 0101 & 0001  | 0001 | 1      |
| \|     | 或           | 5 \| 1  | 0101 \| 0001 | 0101 | 5      |
| ~      | 非           | ~ 5     | ~0101        | 1010 | 10     |
| ^      | 异或         | 5 ^ 1   | 0101 ^ 0001  | 0100 | 4      |
| <<     | 零填充左位移 | 5 << 1  | 0101 << 1    | 1010 | 10     |
| >>     | 有符号右位移 | 5 >> 1  | 0101 >> 1    | 0010 | 2      |
| >>>    | 零填充右位移 | 5 >>> 1 | 0101 >>> 1   | 0010 | 2      |

2. #### 函数、作用域、闭包

   JS 在寻找变量时，会从内向外寻找变量。

   闭包如下例子

   ```javascript
   function 创建计数器() {
     let 计数 = 0; // 被"封闭"的变量
     return function () {
       计数++;
       return 计数;
     };
   }

   const 计数器 = 创建计数器();
   console.log(计数器()); // 1
   console.log(计数器()); // 2
   ```

闭包内部函数始终持有对外部变量计数的引用外部函数执行后，其作用域不会被销毁。简单来说，外部变量进入内部函数时，会被暂时封存起来，在内部进行操作不影响外部变量。

3. #### 对象、原型、继承

原型：可以通过原型来创造隐式构造函数通过 object.prototype.{{value}}来创造函数或者变量例如以下例子

```javascript
//通过 prototype来对对象内部属性进行默认赋值
function 猎人() {}
猎人.prototype.种族 = "阿戈尔";

const 蒂蒂 = new 猎人();
console.log(蒂蒂.种族); // "阿戈尔" （通过__proto__查找）

//修改原型
// 添加共享方法
猎人.prototype.觉醒 = function () {
  console.log(`${this.名字}解放深海之力！`);
};

// 所有实例都能调用
幽灵鲨.觉醒(); // "幽灵鲨解放深海之力！"
```

4. #### 事件处理

   click 点击
   mouseover/mouseout 鼠标移入/出
   keydown/keyup 键盘按下/释放
   scroll 页面滚动
   submit 表单提交

   可以在父组件加监听器，再通过筛选选择子组件对应的行动

   ```html
   <body>
     <div id="深海猎人">
       <button class="skill" data-name="潮涌">潮涌斩</button>
       <button class="skill" data-name="浪蚀">浪蚀旋涡</button>
       <button class="getback" data-name="撤退">撤退</button>
     </div>

     <script>
       document.getElementById("深海猎人").addEventListener("click", (e) => {
         if (e.target.classList.contains("skill")) {
           const 技能名 = e.target.dataset.name;
           if (e.target.classList.contains("cooldown")) {
             alert(`${技能名}冷却中`);
             return;
           }
           alert(`斯卡蒂发动${技能名}！`);
           e.target.classList.add("cooldown");
           setTimeout(() => {
             e.target.classList.remove("cooldown");
           }, 4000);
         }
         if (e.target.classList.contains("getback")) {
           alert("撤退成功！");
         }
       });
     </script>
   </body>
   ```

5. #### AJAX、JSON

AJAX (Asynchronous JavaScript and XML)

异步通信：允许网页在不刷新整个页面的情况下，与服务器交换数据并更新部分内容

核心对象：使用 XMLHttpRequest 或现代更常用的 fetch API 来实现。

用途：直接对后端进行请求，通过返回的数据对页面进行更新，从而不更新页面也可以修改页面现有数据。

```js
//使用XMLHttoRequest
// 像斯卡蒂准备拔剑一样初始化请求
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://api.example.com/dossoles-holiday", true);

// 设置回调，就像等待博士的指令
xhr.onload = function () {
  if (xhr.status === 200) {
    const response = JSON.parse(xhr.responseText);
    console.log(response); // 处理深海猎人数据~
  }
};

// 发送请求，如同挥出剑击
xhr.send();

//使用detch
// 更现代的写法
fetch("https://api.example.com/arknights/operator/skadi")
  .then((response) => response.json()) // 把响应解析成JSON
  .then((data) => {
    console.log(data.stats); // 输出斯卡蒂的属性数据
  })
  .catch((error) => {
    console.error("请求失败啦~", error); // 就像演习失败时一样
  });
```

6. #### ES6 特性

箭头函数

```js
// 旧写法像重装干员一样笨重
const oldFunc = function (a, b) {
  return a + b;
};

// 新写法像快速复活干员一样轻便
const newFunc = (a, b) => a + b;
// 单参数可省略括号
const skadiLove = (dokutah) => dokutah + "❤️";
```

模板字符串

```js
const operator = "斯卡蒂";
const level = 90;
// 旧写法像拼装坦克零件一样麻烦
console.log("我的" + operator + "已经" + level + "级了");

// 新写法像德系坦克的流畅炮线
console.log(`我的${operator}已经${level}级了，想看看她的新技能吗~`);
```

const 变量无法重新赋值，let 和 var 用法相似

解构赋值指在变量赋值时可以直接用新对象进行赋值，会自动匹配相同字段进行赋值。

```js
// 像拆解战雷的坦克配件一样优雅
const skadi = { name: "斯卡蒂", type: "剑圣", height: 166 };

// 旧写法
const name = skadi.name;
const type = skadi.type;

// 新写法
const { name, type } = skadi;
console.log(`${name}是${type}职业哦~`);
```

7. #### 模块化

commonjs 模块化

```js
// skadi_stats.js
module.exports = {
  codename: "Skadi",
  height: 166,
  weight: 50,
  affection: 100,
};

//其他文件导入
// 在另一个文件引入，像调取机密档案
const skadi = require("./skadi_stats.js");
console.log(`${skadi.codename}`);
```

ES6 模块化

```js
// 像德系顶级房开局的精准锁定
import { skadi, swimVer } from './arknights.js';

// 默认导出像斯卡蒂的必杀技
export default function深海斩击() {
  console.log("博士...要上了！");
}

```

8. #### Promise、async/await

promise 是一个类，通过 new 一个 promis 来实现等待和异步操作，包括两个默认回调函数 resolve-成功时调用，reject-失败时调用。

```js
// 像等待斯卡蒂的作战记录
const skadiPromise = new Promise((resolve, reject) => {
  const isSuccess = Math.random() > 0.3; // 70%成功率

  setTimeout(() => {
    isSuccess
      ? resolve("斯卡蒂带着记录回来了！")
      : reject("斯卡蒂被幽灵鲨拐走了...");
  }, 2000); // 模拟2秒延迟
});

// 使用方式
skadiPromise
  .then((result) => console.log(`成功: ${result}`)) // 像收到礼物
  .catch((error) => console.error(`失败: ${error}`)); // 像演习失败
```

通过 async 声明一个函数为异步函数，来实现 promise 类似的效果，返回的结果相当于 Promise.resolve

```js
// 像在基建里等待干员换班
async function deploySkadi() {
  try {
    console.log("正在部署斯卡蒂...");
    const result = await skadiPromise;
    console.log(`部署结果: ${result}`);

    // 可以连续await，像连续作战
    const swimsuit = await fetchSwimsuitData();
    return "博士...";
  } catch (error) {
    console.log(`啊啦~出问题了: ${error}`);
    throw "需要补偿理智吗？";
  }
}
```

await 在 async 函数中使用，会等待后续 promise 函数结束执行

9. #### 浏览器存储（cookie、localStorage、sessionStorage）

cookie

- 每次请求自动携带
- 4KB 限制
- 需要手动处理字符串

放入的每一个属性是一个 cookie

```js
// 像给博士设置专属饼干
document.cookie = "skadi_fan=true; expires=Fri, 31 Dec 2025; path=/";
document.cookie = "favorite_swimsuit=ver2; max-age=3600"; // 1小时有效

// 读取时像翻找私人物品
const cookies = document.cookie.split(";");
console.log(cookies.find((c) => c.includes("favorite_swimsuit")));
```

localStorage

- 5MB 容量
- 除非手动删除否则永久保存
- 同源共享

```js
localStorage.setItem(
  "skadi_stats",
  JSON.stringify({
    attack: 1145,
    swimsuits: ["ver1", "ver2", "ver3"],
  })
);

// 读取
const data = JSON.parse(localStorage.getItem("skadi_stats"));
console.log(data.swimsuits[1]); // 输出ver2
```

sessionStorage

- 标签页关闭自动清除

- 5MB 容量

- 不同标签页不共享

```js
// 像战雷一局游戏的临时数据
sessionStorage.setItem("current_battle", "德系6.7街机");

// 关闭标签页就消失，像梦醒时分
console.log(sessionStorage.getItem("current_battle"));
```
