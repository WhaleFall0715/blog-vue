---
date: 2025-08-13
category:
  - 日常博客
tag:
  - 工作笔记
sticky: false
---
## 第一周笔记

## HTML

1. #### 标签
   
   标题标签：&lt;/h1&gt;&lt;/h2&gt;
   分块标签：
   
       </div&gt;
   
       </section&gt;-一般用于有明确意义可以分发的分块，内部应该有标题  
   
       </article&gt;-一般用于有明确独立内容的分组  
   换行标签：
   
       </br>
   
       </p>-自带上下边距
   
   超链接标签：
   
       </a>-属性：herf必填，表示目标；target，控制链接打开方式-新标签页、本标签页等；herf内填写#{{id}}可以对id匹配进行跳转

2. #### 属性
   
   身份属性：id-唯一，class-不唯一
   
   样式属性：style常用属性：color文字颜色；font-size字体大小；font-family字体类型；font-weight字体粗细；text-align文字对齐；text-decoration文字装饰：下划线，中划线等；line-height行高；margin外边距：与其他组件的边距；padding内边距：内容与容器的边距；top、right、bottom、left上下左右定位偏移；transition过渡效果；transform变形。

3. #### 表单
   
   </form>为表单，基本属性有：action指定表单提交url；method提交方式-GET和POST；enctype编码类型。
   
   内置标签：
   
   </input>标签，属性有：type输入属性-text、password、email、number、date、file等；name字段名称；value默认值；placeholder输入框内文本；required必须字段；readonly只读；disabled禁用。
   
   </select>标签，下拉菜单选择。
   
   </textarea>标签，多行文本，输入区域。

4. #### 图像
   
   </img>标签，基本属性有：src图像源，必填；alt代替文本，当图像没加载出来时显示；width和height宽高；loading加载属性，有lazy-延迟加载和eager-立即加载；

## CSS

1. #### 选择器：
   
   基本选择器：*-选择所有标签；{{tag}}-标签选择器；.{{class}}-类选择器；#{{id}}-ID选择器
   
   组合选择器：{{A}}，{{B}}-分组选择；{{A}} {{B}}-选择父容器内所有的子容器；{{A}}>{{B}}-只选择直接子容器；{{A}}+{{B}}-选择同一父容器中的匹配A的紧邻B容器；{{A}}~{{B}}-选择同一父容器下的匹配A的后续所有B容器

2. #### 基础属性

        外观属性：color颜色，background背景，border边框，box-shadow容器阴影。

        布局属性：

        display展示类型，属性有：block-独占一行可以设置宽高；inline-随行内流动，无法设置宽高（会使margin和padding上下无效）；inline-block-行内排列可以设置宽高；flex-弹性容器，子内容自由伸缩；gird-二维网格布局，使用gird-template-columns设置形式。

```css
{  
  display: grid;  
  grid-template-columns: repeat(3, 1fr); /* 三列等宽 */  
}  
```

3. #### 盒模型

         由外到内四个层次，依次是margin-border-padding-content，有两种盒模型：content-box标准盒模型，总宽度等于外三层一起；border-box怪异盒模型，总宽度定死大小，不受padding和border影响。

        如果想要网页内容和网页没有间隙，需要将body的margin和padding手动设置为0，实现没有空隙。

## JavaScript

1. #### 数据类型

        number-浮点、整型，string，boolean，null，undefined，symbol-唯一标识符，bigint-大整型

        以上为原始类型，在运行时直接取对象值

        下面为引用类型，运行时取对象地址，地址数据改变时，所有信息改变

        object-键值对集合，array-有序列表，function，Date，RegExp-正则表达式

| 运算符 | 意义         | 例子    | 等同于       | 结果 | 十进制 |
| ------ | ------------ | ------- | ------------ | ---- | ------ |
| &      | 与           | 5 & 1   | 0101 & 0001  | 0001 | 1      |
| \|     | 或           | 5 \| 1  | 0101 \| 0001 | 0101 | 5      |
| ~      | 非           | ~ 5     | ~0101        | 1010 | 10     |
| ^      | 异或         | 5 ^ 1   | 0101 ^ 0001  | 0100 | 4      |
| <<     | 零填充左位移 | 5 << 1  | 0101 << 1    | 1010 | 10     |
| >>     | 有符号右位移 | 5 >> 1  | 0101 >> 1    | 0010 | 2      |
| >>>    | 零填充右位移 | 5 >>> 1 | 0101 >>> 1   | 0010 | 2      |

2. #### 函数、作用域、闭包
   
   JS在寻找变量时，会从内向外寻找变量。
   
   闭包如下例子
   
   ```javascript
   function 创建计数器() {  
     let 计数 = 0; // 被"封闭"的变量  
     return function() {  
       计数++;  
       return 计数;  
     };  
   }  
   
   const 计数器 = 创建计数器();  
   console.log(计数器()); // 1  
   console.log(计数器()); // 2  
   ```

        闭包内部函数始终持有对外部变量计数的引用外部函数执行后，其作用域不会被销毁。简单来说，外部变量进入内部函数时，会被暂时封存起来，在内部进行操作不影响外部变量。

3. #### 对象、原型、继承

        原型：可以通过原型来创造隐式构造函数通过object.prototype.{{value}}来创造函数或者变量例如以下例子

```javascript
//通过 prototype来对对象内部属性进行默认赋值
function 猎人() {}  
猎人.prototype.种族 = "阿戈尔";  

const 蒂蒂 = new 猎人();  
console.log(蒂蒂.种族); // "阿戈尔" （通过__proto__查找）  

//修改原型
// 添加共享方法  
猎人.prototype.觉醒 = function() {  
  console.log(`${this.名字}解放深海之力！`);  
};  

// 所有实例都能调用  
幽灵鲨.觉醒(); // "幽灵鲨解放深海之力！"  

```

4. #### 事件处理
   
   click    点击
   mouseover/mouseout    鼠标移入/出
   keydown/keyup    键盘按下/释放
   scroll    页面滚动
   submit    表单提交
   
   可以在父组件加监听器，再通过筛选选择子组件对应的行动
   
   ```html
   <body>
       <div id="深海猎人">
         <button class="skill" data-name="潮涌">潮涌斩</button>
         <button class="skill" data-name="浪蚀">浪蚀旋涡</button>
         <button class="getback" data-name="撤退">撤退</button>
       </div>
   
       <script>
         document.getElementById("深海猎人").addEventListener("click", (e) => {
           if (e.target.classList.contains("skill")) {
             const 技能名 = e.target.dataset.name;
             if (e.target.classList.contains("cooldown")) {
               alert(`${技能名}冷却中`);
               return;
             }
             alert(`斯卡蒂发动${技能名}！`);
             e.target.classList.add("cooldown");
             setTimeout(() => {
               e.target.classList.remove("cooldown");
             }, 4000);
           }
           if (e.target.classList.contains("getback")) {
             alert("撤退成功！");
           }
         });
       </script>
     </body>
   ```

5. #### AJAX、JSON

        AJAX (Asynchronous JavaScript and XML)

        异步通信：允许网页在不刷新整个页面的情况下，与服务器交换数据并更新部分内容

         核心对象：使用 XMLHttpRequest 或现代更常用的 fetch API 来实现。

        用途：直接对后端进行请求，通过返回的数据对页面进行更新，从而不更新页面也可以修改页面现有数据。

```js
//使用XMLHttoRequest
// 像斯卡蒂准备拔剑一样初始化请求
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/dossoles-holiday', true);

// 设置回调，就像等待博士的指令
xhr.onload = function() {
  if (xhr.status === 200) {
    const response = JSON.parse(xhr.responseText);
    console.log(response); // 处理深海猎人数据~
  }
};

// 发送请求，如同挥出剑击
xhr.send();

//使用detch
// 更现代的写法
fetch('https://api.example.com/arknights/operator/skadi')
  .then(response => response.json()) // 把响应解析成JSON
  .then(data => {
    console.log(data.stats); // 输出斯卡蒂的属性数据
  })
  .catch(error => {
    console.error('请求失败啦~', error); // 就像演习失败时一样
  });

```

6. #### ES6特性

        箭头函数

```js
// 旧写法像重装干员一样笨重
const oldFunc = function(a, b) { return a + b; };

// 新写法像快速复活干员一样轻便
const newFunc = (a, b) => a + b;
// 单参数可省略括号
const skadiLove = dokutah => dokutah + "❤️";

```

        模板字符串

```js
const operator = "斯卡蒂";
const level = 90;
// 旧写法像拼装坦克零件一样麻烦
console.log("我的" + operator + "已经" + level + "级了");

// 新写法像德系坦克的流畅炮线
console.log(`我的${operator}已经${level}级了，想看看她的新技能吗~`);


```

        const变量无法重新赋值，let和var用法相似

        解构赋值指在变量赋值时可以直接用新对象进行赋值，会自动匹配相同字段进行赋值。

```js
// 像拆解战雷的坦克配件一样优雅
const skadi = { name: "斯卡蒂", type: "剑圣", height: 166 };

// 旧写法
const name = skadi.name;
const type = skadi.type;

// 新写法
const { name, type } = skadi;
console.log(`${name}是${type}职业哦~`);


```

7. #### 模块化

commonjs模块化

```js
   // skadi_stats.js 
   module.exports = {
       codename: "Skadi",
       height: 166,
       weight: 50,
       affection: 100 
   };


   //其他文件导入
   // 在另一个文件引入，像调取机密档案
   const skadi = require('./skadi_stats.js');
   console.log(`${skadi.codename}`);


```

ES6模块化

```js
// 像德系顶级房开局的精准锁定
import { skadi, swimVer } from './arknights.js';  

// 默认导出像斯卡蒂的必杀技
export default function深海斩击() {
  console.log("博士...要上了！");
}

```

8. #### Promise、async/await

        promise是一个类，通过new一个promis来实现等待和异步操作，包括两个默认回调函数resolve-成功时调用，reject-失败时调用。

```js
   // 像等待斯卡蒂的作战记录
   const skadiPromise = new Promise((resolve, reject) => {
     const isSuccess = Math.random() > 0.3; // 70%成功率

     setTimeout(() => {
       isSuccess 
         ? resolve("斯卡蒂带着记录回来了！") 
         : reject("斯卡蒂被幽灵鲨拐走了...");
     }, 2000); // 模拟2秒延迟
   });

   // 使用方式
   skadiPromise
     .then(result => console.log(`成功: ${result}`)) // 像收到礼物
     .catch(error => console.error(`失败: ${error}`)); // 像演习失败

```

    通过async声明一个函数为异步函数，来实现promise类似的效果，返回的结果相当于Promise.resolve

```js
// 像在基建里等待干员换班
async function deploySkadi() {
  try {
    console.log("正在部署斯卡蒂...");
    const result = await skadiPromise;
    console.log(`部署结果: ${result}`);

    // 可以连续await，像连续作战
    const swimsuit = await fetchSwimsuitData(); 
    return "博士...";
  } catch (error) {
    console.log(`啊啦~出问题了: ${error}`);
    throw "需要补偿理智吗？";
  }
}


```

    await在async函数中使用，会等待后续promise函数结束执行

9. #### 浏览器存储（cookie、localStorage、sessionStorage）

     cookie

- 每次请求自动携带
- 4KB限制
- 需要手动处理字符串

    放入的每一个属性是一个cookie

```js
// 像给博士设置专属饼干
document.cookie = "skadi_fan=true; expires=Fri, 31 Dec 2025; path=/";
document.cookie = "favorite_swimsuit=ver2; max-age=3600"; // 1小时有效

// 读取时像翻找私人物品
const cookies = document.cookie.split(';');
console.log(cookies.find(c => c.includes('favorite_swimsuit')));

```

    localStorage 

- 5MB容量
- 除非手动删除否则永久保存
- 同源共享

```js
  localStorage.setItem('skadi_stats', JSON.stringify({
    attack: 1145,
    swimsuits: ['ver1', 'ver2', 'ver3']
  }));

  // 读取
  const data = JSON.parse(localStorage.getItem('skadi_stats'));
  console.log(data.swimsuits[1]); // 输出ver2

```

    sessionStorage     

- 标签页关闭自动清除

- 5MB容量

- 不同标签页不共享

```js
    // 像战雷一局游戏的临时数据
  sessionStorage.setItem('current_battle', '德系6.7街机');

  // 关闭标签页就消失，像梦醒时分
  console.log(sessionStorage.getItem('current_battle'));
```
