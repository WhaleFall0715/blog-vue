---
title: 牛马日记之第六周
date: 2025-08-13
category:
  - 日常博客
tag:
  - 日常
  - 工作笔记
sticky: false
---

<!-- more -->

## 1.组合式函数

​ 组合式函数的思想与 java 类似，将一个功能进行封装，然后暴露对外接口，功能内部运作为黑箱，只有输入喝输出，相对于选项式函数来说，组合式函数的复用率更高，编写更加简洁。

​ 在组合式函数中，异步函数也是重点之一，将异步操作也封装成函数，也可以使代码更加简洁

```vue
<!-- 这样编写的异步代码，在每次使用时都需要进行编写，代码量和维护难度都会变高 -->
<script setup>
import { ref } from "vue";

const data = ref(null);
const error = ref(null);

fetch("...")
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err));
</script>

<template>
  <div v-if="error">Oops! Error encountered: {{ error.message }}</div>
  <div v-else-if="data">
    Data loaded:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Loading...</div>
</template>
```

转化为下述模块就可以简单解决

```vue
// fetch.js
<script setup>
import { ref } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))

  return { data, error }
}
//再到其他组件中使用即可
<script setup>
import { useFetch } from './fetch.js'

const { data, error } = useFetch('...')
</script>
```

​ 在这种异步组件中，将 url 变为响应式对象，就可以在每次修改 url 的时候进行改变

### 约定和最佳实现

​ 组合式函数约定用驼峰命名法命名，并以“use”作为开头。

​ 输入时使用 toVlaue 更加规范

```js
import { toValue } from "vue";

function useFeature(maybeRefOrGetter) {
  // 如果 maybeRefOrGetter 是一个 ref 或 getter，
  // 将返回它的规范化值。
  // 否则原样返回。
  const value = toValue(maybeRefOrGetter);
}
```

​ 返回时的返回值也使用 ref，将一个响应式函数用 reactive 包起来，可以将返回值变为一个响应式对象，并且可以直接使用

```js
const mouse = reactive(useMouse())
// mouse.x 链接到了原来的 x ref
console.log(mouse.x)
//页面内使用
Mouse position is at: {{ mouse.x }}, {{ mouse.y }}
```

​ 组合式函数只能在 `<script setup>` 或 `setup()` 钩子中被调用。在这些上下文中，它们也只能被**同步**调用。如果在选项式语法中使用，只能在 setup 中使用函数，返回值也只能在 setup 中。

## 2.自定义指令

​ VUE3 可以在 main.ts 中定义全局自定义指令，或者在模块中定义局部指令，使用方法如下

```ts
//局部指令
const app = createApp({});

// 使 v-highlight 在所有组件中都可用
app.directive("highlight", {
  /* ... */
});
```

​ 指令也有一些钩子函数，使用这些函数在 directive 内，可以调整执行时间

```js
const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode) {},
};
```

​ 指定绑定时的 binding

```vue
<div v-example:foo.bar="baz">
{
  arg: 'foo',
  modifiers: { bar: true },
  value: /* `baz` 的值 */,
  oldValue: /* 上一次更新时 `baz` 的值 */
}
```

## 3.Transition

​ 这位更是重量级，一个标签就相当于全局动画变量了

​ `<Transition>` 会在一个元素或组件进入和离开 DOM 时应用动画。使用 name 属性来定制不同名字下的动画，下面为六个阶段。

1. `v-enter-from`：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。
2. `v-enter-active`：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。
3. `v-enter-to`：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 `v-enter-from` 被移除的同时)，在过渡或动画完成之后移除。
4. `v-leave-from`：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。
5. `v-leave-active`：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。
6. `v-leave-to`：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 `v-leave-from` 被移除的同时)，在过渡或动画完成之后移除。

​ 使用.name-阶段来对 name 标签下的组件定制动画

​ 对于大多数的 CSS 动画，我们可以简单地在 `*-enter-active` 和 `*-leave-active` class 下声明它们。下面是一个示例：

```vue
<Transition name="bounce">
    <p v-if="show" style="text-align: center;">
        Hello here is some bouncy text!
    </p>
</Transition>

<style>
.bounce-enter-active {
  animation: bounce-in 0.5s;
}
.bounce-leave-active {
  animation: bounce-in 0.5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.25);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```

​ 使用自定义 class，通过传入 props 实现自定义 class，引入第三方动画等

- `enter-from-class`

- `enter-active-class`

- `enter-to-class`

- `leave-from-class`

- `leave-active-class`

- `leave-to-class`

  ```vue
  <!-- 假设你已经在页面中引入了 Animate.css -->
  <Transition
    name="custom-classes"
    enter-active-class="animate__animated animate__tada"
    leave-active-class="animate__animated animate__bounceOutRight"
  >
    <p v-if="show">hello</p>
  </Transition>
  ```

  通过这种方式直接对 class 进行覆盖，可以直接实现第三方动画。

​ Vue 需要附加事件监听器，以便知道过渡何时结束。可以是 `transitionend` 或 `animationend`，这取决于你所应用的 CSS 规则。如果你仅仅使用二者的其中之一，Vue 可以自动探测到正确的类型。

​ 然而在某些场景中，你或许想要在同一个元素上同时使用它们两个。举例来说，Vue 触发了一个 CSS 动画，同时鼠标悬停触发另一个 CSS 过渡。此时你需要显式地传入 `type` prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 `animation` 或 `transition`。`<Transition type="animation">...</Transition>`

​ 还可以使用子组件类的形式实现不同动画的延迟，动画阶段+类名可以实现。

​ 使用 css=false 的 props 实现禁止 css 覆盖，在 transition 中插入一个 slot 就可以实现效果复用。某个节点初次渲染时应用一个过渡效果，以添加 `appear`的 prop

​ transition 也有钩子函数

```vue
<Transition
  @before-enter="onBeforeEnter"
  @enter="onEnter"
  @after-enter="onAfterEnter"
  @enter-cancelled="onEnterCancelled"
  @before-leave="onBeforeLeave"
  @leave="onLeave"
  @after-leave="onAfterLeave"
  @leave-cancelled="onLeaveCancelled"
>
    <!-- ... -->
</Transition>
<script>
// 在元素被插入到 DOM 之前被调用
// 用这个来设置元素的 "enter-from" 状态
function onBeforeEnter(el) {}

// 在元素被插入到 DOM 之后的下一帧被调用
// 用这个来开始进入动画
function onEnter(el, done) {
  // 调用回调函数 done 表示过渡结束
  // 如果与 CSS 结合使用，则这个回调是可选参数
  done();
}

// 当进入过渡完成时调用。
function onAfterEnter(el) {}

// 当进入过渡在完成之前被取消时调用
function onEnterCancelled(el) {}

// 在 leave 钩子之前调用
// 大多数时候，你应该只会用到 leave 钩子
function onBeforeLeave(el) {}

// 在离开过渡开始时调用
// 用这个来开始离开动画
function onLeave(el, done) {
  // 调用回调函数 done 表示过渡结束
  // 如果与 CSS 结合使用，则这个回调是可选参数
  done();
}

// 在离开过渡完成、
// 且元素已从 DOM 中移除时调用
function onAfterLeave(el) {}

// 仅在 v-show 过渡中可用
function onLeaveCancelled(el) {}
</script>
```

​ 可以传入 mode 的 props 实现动画行为，例如

```vue
<!--先执行离开动画，然后在其完成之后再执行元素的进入动画-->
<Transition mode="out-in">
  ...
</Transition>
```

## 4.KeepAlive

​ 使用 keepalive 标签实现对组件的缓存，使用 include，exclude 实现包含和去除，使用 max 实现最大缓存

```vue
<!-- 以英文逗号分隔的字符串 -->
<KeepAlive include="a,b">
  <component :is="view" />
</KeepAlive>

<!-- 正则表达式 (需使用 `v-bind`) -->
<KeepAlive :include="/a|b/">
  <component :is="view" />
</KeepAlive>

<!-- 数组 (需使用 `v-bind`) -->
<KeepAlive :include="['a', 'b']">
  <component :is="view" />
</KeepAlive>

<KeepAlive :max="10">
  <component :is="activeComponent" />
</KeepAlive>

<script setup>
import { onActivated, onDeactivated } from 'vue'
<!--一个持续存在的组件可以通过onActivated和onDeactivated注册相应的两个状态的生命周期钩子 -->
onActivated(() => {
  // 调用时机为首次挂载
  // 以及每次从缓存中被重新插入时
})

onDeactivated(() => {
  // 在从 DOM 上移除、进入缓存
  // 以及组件卸载时调用
})
</script>
```
